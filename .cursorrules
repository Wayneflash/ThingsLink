# IoT物联网设备管理平台开发规约

> Vue 3 + Spring Boot + MySQL + EMQX (MQTT) + Redis
> 支持1W设备并发，167条/秒写入量，基于设备分组的数据权限体系

---

## 🎯 核心原则

### 0. 开发流程规范 ⚠️⚠️⚠️⚠️⚠️（最高优先级）
1. **功能开发前必须生成方案原型**
   - 每次开发新功能前，必须先生成详细的开发方案原型
   - 方案原型必须包含：功能描述、涉及的文件清单、修改内容说明、影响范围分析
   - 方案原型保存在 `plans/` 目录，命名格式：`XXX-功能名称.md`
   - **必须等待用户确认方案后才能开始开发**

2. **修改前必须先确认**
   - 开发新功能或修复功能时，必须先明确列出要修改的文件清单
   - 必须说明每个文件的修改内容、修改原因、影响范围
   - **必须等待用户确认"OK"后才能开始修改代码**
   - 禁止未经确认就直接修改代码

3. **保护原有功能**
   - 新开发功能不能影响原有功能的正常运行
   - 修改现有文件时，必须保持原有功能逻辑不变
   - 新增功能必须独立实现，避免与原有代码耦合
   - 如果必须修改原有代码，必须先分析影响范围，并获得用户确认

4. **影响范围评估**
   - 修改代码前必须分析影响范围（哪些功能可能受影响）
   - 修改后端接口时，必须评估是否影响前端调用
   - 修改前端组件时，必须评估是否影响其他页面
   - 修改数据库结构时，必须评估是否影响现有业务逻辑

### 1. 修改优先级 ⚠️⚠️⚠️
1. **优先修改前端** - 能前端解决的问题，不要动后端
2. **后端修改需询问** - 必须修改后端时，先询问用户确认
3. **保持后端稳定** - 不要为了解决问题就乱改后端

### 2. UI设计风格（Apple风格）
- **字体**：`-apple-system, BlinkMacSystemFont, 'SF Pro Display'`
- **颜色**：主色`#007aff`，成功`#34c759`，警告`#ff9500`，危险`#ff3b30`
- **背景**：页面`#f5f5f7`，卡片`#ffffff`
- **圆角**：6px/10px/16px/20px
- **间距**：8px倍数

### 3. 数据权限（全局统一）
- **超级管理员**：查看所有数据（不过滤）
- **普通用户**：只能查看本分组及下级分组数据
- **过滤字段**：用户表、设备表、告警日志表都使用 `group_id` 过滤

### 4. API接口规范
- 统一POST方法，JSON格式
- 统一响应：`{code, message, data}`
- **禁止前端硬编码业务数据**，必须从后端API获取

### 5. 分组组件（强制统一）
- 下拉选择：使用 `GroupSelector` 组件
- 树形展示：使用 `GroupTree` 组件
- **禁止重复实现分组功能**

### 6. 性能要求
- 列表查询 < 500ms
- 必须分页查询，禁止一次性加载
- 禁止循环中执行数据库操作
- MQTT消息异步处理

---

## ✅ 必须遵守的规则

### API文档管理规则 ⚠️⚠️⚠️（最高优先级）
```
⚠️ 所有API接口变更必须先更新API文档，再进行开发！

📁 API文档位置：docs/API.md

🔥 核心原则（必须遵守）：
   1. 开发新功能前，必须先更新API文档
   2. API文档必须包含完整的接口定义（请求参数、响应格式、权限说明）
   3. 修改现有接口时，必须先更新API文档中的接口定义
   4. API文档更新后，必须等待用户确认"OK"才能开始开发
   5. 开发完成后，必须验证API文档与实际接口的一致性

🔹 新增API接口时：
   1. ✅ 必须在 docs/API.md 中新增接口文档
   2. 文档必须包含：
      - 接口路径和方法
      - 请求参数（必填/可选、类型、说明）
      - 响应格式（成功/失败示例）
      - 权限说明（是否需要认证、权限要求）
      - 特殊说明（如有）
   3. 按照文档中的格式和风格编写
   4. 等待用户确认API文档后，再开始开发

🔹 修改现有API接口时：
   1. ✅ 必须先更新 docs/API.md 中对应的接口文档
   2. 明确标注变更内容（新增字段、修改字段、删除字段）
   3. 说明变更原因和影响范围
   4. 等待用户确认API文档变更后，再开始修改代码

🔹 API文档格式要求：
   - 使用Markdown格式
   - 接口按模块分类组织
   - 每个接口包含完整的请求/响应示例
   - 使用表格、代码块等提高可读性
   - 保持文档的专业性和可视化

⚠️ API文档更新后的步骤：
   1. 更新 docs/API.md
   2. 展示给用户确认
   3. 等待用户确认"OK"
   4. 生成开发方案原型（plans/XXX-功能名称.md）
   5. 等待用户确认方案
   6. 开始开发
   7. 开发完成后验证API文档与实际接口的一致性
```

### 开发流程（严格执行）
```
⚠️ 开发新功能或修复功能时的标准流程：

1. 更新API文档（如涉及API接口）
   → 更新 docs/API.md
   → 详细说明接口定义、请求参数、响应格式
   → 等待用户确认API文档"OK"
   
2. 生成方案原型
   → 创建 plans/XXX-功能名称.md 文件
   → 详细说明：功能描述、文件清单、修改内容、影响范围
   
3. 等待用户确认
   → 展示方案给用户
   → 等待用户确认"OK"或提出修改意见
   
4. 列出修改清单
   → 明确列出要修改的文件路径
   → 说明每个文件的修改内容和原因
   
5. 再次确认
   → 等待用户确认"OK"后才能开始修改
   
6. 开始开发
   → 按照确认的方案进行开发
   → 确保不影响原有功能
   → 开发完成后验证API文档与实际接口的一致性
```

### 后端修改后自动编译
```
修改后端代码后，执行：cd backend && mvn package -DskipTests
编译完成后提醒用户重启后端服务
```

### 设备列表排序
```sql
ORDER BY status DESC, create_time DESC  -- 在线优先，时间降序
```

### 弹窗设计
- 内容在视窗内完整显示，最大高度96vh
- 禁止出现滚动条（列表区域除外）

### 时间格式
```
格式：yyyy-MM-dd HH:mm:ss
示例：2026-01-10 08:42:49
禁止：ISO 8601格式（带T的格式）
```

### 脚本编写规则 ⚠️⚠️⚠️
```
⚠️ 所有脚本必须支持在不同电脑上运行，禁止硬编码绝对路径！

📁 脚本目录：scripts/
🔹 脚本开头必须使用相对路径：
   @echo off
   setlocal enabledelayedexpansion
   chcp 65001 >nul
   
   REM 获取脚本所在目录（自动适配不同路径）
   set SCRIPT_DIR=%~dp0
   set SCRIPT_DIR=!SCRIPT_DIR:~0,-1!
   
   REM 切换到项目根目录
   cd /d "!SCRIPT_DIR!\.."

🔹 配置信息放在单独的配置文件：
   - 配置文件：scripts/deploy-config.txt
   - 模板文件：scripts/deploy-config.template.txt
   - 配置文件不提交到Git（已在.gitignore中）

🔹 危险操作必须二次确认：
   - Git pull/push 等会覆盖代码的操作
   - 删除文件/目录的操作
   - 需要先显示当前状态，让用户知道会影响什么
   - 使用 set /p CONFIRM="确认？(Y/N): " 获取用户确认

❌ 禁止行为：
   - 硬编码绝对路径（如 D:\AICoding\IOT）
   - 硬编码用户名、密码到脚本中
   - 依赖特定电脑的环境变量
   - 危险操作不经确认直接执行
```

### 数据库迁移规则 ⚠️⚠️⚠️（最高优先级）
```
⚠️ 数据库结构变更必须通过迁移脚本管理，保护生产数据的安全！

📁 迁移脚本目录：sql/migrations/
📋 服务器现有表（15张）：
   - system_config, tb_alarm_log, tb_attribute, tb_command, tb_command_log
   - tb_device, tb_device_data, tb_device_group, tb_device_log, tb_menu
   - tb_migration_history, tb_notification, tb_product, tb_role, tb_user

🔥 核心原则（必须遵守）：
   1. 所有新建表必须放在 sql/migrations/ 目录
   2. 迁移脚本必须是幂等的（可重复执行）
   3. 只能新增字段/表，绝不删除或修改现有字段
   4. 不能影响远端数据库的现有数据
   5. 同步到生产环境前必须在本地测试

🔹 新增功能需要新建表时：
   1. ✅ 必须在 sql/migrations/ 目录创建迁移脚本
   2. 文件命名：XXX_功能描述.sql（如：003_create_device_data_table.sql）
   3. ✅ 必须使用 CREATE TABLE IF NOT EXISTS 语法（幂等性）
   4. 添加迁移历史记录（见示例）
   5. 示例：
      CREATE TABLE IF NOT EXISTS `tb_new_table` (
          `id` BIGINT AUTO_INCREMENT PRIMARY KEY,
          `name` VARCHAR(100) NOT NULL,
          `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
          PRIMARY KEY (`id`)
      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='新表说明';
      
      -- 记录迁移历史
      INSERT INTO tb_migration_history (migration_file, status, executed_at) 
      VALUES ('003_create_new_table.sql', 'success', NOW())
      ON DUPLICATE KEY UPDATE status = 'success', executed_at = NOW();

🔹 现有表需要新增字段时（只能新增，不能删除/修改）：
   1. ✅ 必须在 sql/migrations/ 目录创建迁移脚本
   2. ✅ 必须使用安全的 ALTER TABLE 语法，先检查字段是否存在（幂等性）
   3. ✅ 只能 ADD COLUMN，绝不 DROP COLUMN 或 MODIFY COLUMN
   4. 新字段必须允许 NULL 或有默认值（不影响现有数据）
   5. 示例：
      -- 检查字段是否已存在
      SET @exist := (SELECT COUNT(*) FROM INFORMATION_SCHEMA.COLUMNS 
                     WHERE TABLE_SCHEMA = DATABASE() 
                     AND TABLE_NAME = 'tb_device' 
                     AND COLUMN_NAME = 'new_field');
      
      -- 只在不存在时添加
      SET @sql := IF(@exist = 0, 
          'ALTER TABLE tb_device ADD COLUMN new_field VARCHAR(100) DEFAULT NULL COMMENT ''新字段说明''', 
          'SELECT ''Field already exists'' AS message');
      
      PREPARE stmt FROM @sql;
      EXECUTE stmt;
      DEALLOCATE PREPARE stmt;
      
      -- 记录迁移历史
      INSERT INTO tb_migration_history (migration_file, status, executed_at) 
      VALUES ('004_add_device_field.sql', 'success', NOW())
      ON DUPLICATE KEY UPDATE status = 'success', executed_at = NOW();

🔹 新增索引时：
   -- MySQL 5.7+ 支持 IF NOT EXISTS
   CREATE INDEX IF NOT EXISTS `idx_xxx` ON `tb_xxx` (`field`);
   
   -- 或使用安全检查
   SET @exist := (SELECT COUNT(*) FROM INFORMATION_SCHEMA.STATISTICS
                  WHERE TABLE_SCHEMA = DATABASE()
                  AND TABLE_NAME = 'tb_xxx'
                  AND INDEX_NAME = 'idx_xxx');
   SET @sql := IF(@exist = 0, 
       'CREATE INDEX idx_xxx ON tb_xxx (field)', 
       'SELECT ''Index already exists''');
   PREPARE stmt FROM @sql;
   EXECUTE stmt;
   DEALLOCATE PREPARE stmt;

❌ 绝对禁止的操作（会导致数据丢失或生产事故）：
   - DROP TABLE（删除表）❌
   - TRUNCATE TABLE（清空表）❌
   - DELETE FROM（删除数据）❌
   - DROP COLUMN（删除字段）❌
   - ALTER COLUMN / MODIFY COLUMN（修改字段类型/约束）❌
   - 不带 IF NOT EXISTS 的 CREATE TABLE ❌
   - 直接写 ALTER TABLE ADD COLUMN 不检查是否存在 ❌

⚠️ 迁移脚本编写后的步骤：
   1. 同步更新后端Entity类（如有新表/新字段）
   2. 同步更新后端Mapper（如有新字段）
   3. 本地测试：运行 scripts/sync-db.bat（输入 N 跳过远程）
   4. 验证功能正常后，提醒用户同步到生产环境
   5. 生产同步：运行 scripts/sync-db.bat（输入 Y 同步远程）

🔹 同步脚本使用：
   scripts/sync-db.bat
   - 自动同步本地数据库
   - 询问是否同步远程（Y/N）
   - 幂等设计，可重复执行
   - 不会影响现有数据
```

---

## 📁 关键文件位置

| 类型 | 路径 |
|------|------|
| API文档 | `docs/API.md` |
| 数据库迁移 | `sql/migrations/` |
| 前端API | `frontend/src/api/` |
| 分组组件 | `frontend/src/components/GroupSelector.vue`、`GroupTree.vue` |
| 数据权限 | `backend/.../controller/DeviceController.java` |
| MQTT配置 | `backend/.../mqtt/MqttConfig.java` |
| 数据库同步 | `scripts/sync-db.bat` |

---

## ❌ 禁止行为

- **未经确认直接修改代码** - 必须先生成方案并获得用户确认
- **开发新API接口前不更新API文档** - 必须先更新 docs/API.md 并获得用户确认
- **修改现有API接口前不更新API文档** - 必须先更新API文档中的接口定义
- **修改代码前不分析影响范围** - 必须评估对原有功能的影响
- **破坏原有功能逻辑** - 新功能开发必须保证原有功能正常运行
- 前端硬编码业务数据
- 不同接口使用不同权限逻辑
- 跳过数据权限检查
- 全表扫描、未分页查询
- 同步处理MQTT消息
- DROP/TRUNCATE/DELETE 生产数据

---

*最后更新：2026-01-13*  
*新增：API文档管理规则*
