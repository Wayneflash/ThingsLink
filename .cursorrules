# IoT物联网设备管理平台开发规约

> 本文档定义了IoT平台项目的开发规范和架构原则，所有AI助手必须严格遵守。

---

## 📋 项目概述

### 项目定位
- **项目类型**：IoT物联网设备管理平台
- **技术栈**：Vue 3 + Spring Boot + MySQL + EMQX (MQTT) + Redis
- **核心特点**：
  - **未使用时序数据库**，使用MySQL存储时序数据
  - **性能要求高**，支持1W+设备并发
  - **数据权限严格**，基于设备分组的权限体系
  - **实时性要求高**，MQTT消息实时处理

### 核心业务模块
- 设备管理（设备分组、设备实例、设备状态）
- 产品管理（产品定义、物模型、命令定义）
- 数据管理（设备数据存储、查询、统计）
- 用户权限管理（角色、菜单、数据权限）
- 告警管理（告警阈值配置、告警触发、告警日志）
- MQTT消息处理（设备上报、命令下发）

---

## 🎯 核心架构原则

### 1. 修改优先级原则 ⚠️⚠️⚠️

**必须严格遵守的优先级顺序：**
1. **优先修改前端** - 能前端解决的问题，不要动后端
2. **后端修改需询问** - 必须修改后端时，先询问用户确认
3. **不要为了解决问题就乱改后端** - 保持后端代码的稳定性和一致性

**判断标准：**
- 前端显示问题 → 优先前端适配
- 前端数据格式问题 → 优先前端转换
- 前端交互问题 → 优先前端解决
- 业务逻辑问题 → 询问用户后修改后端

---

### 2. 数据权限统一原则 ⚠️⚠️⚠️

**全局数据权限必须统一实现，所有数据权限逻辑必须完全一致：**

#### 权限模型（全局统一）
- **超级管理员**：可查看所有数据（不受分组限制）
- **普通用户**：只能查看本分组及所有下级分组的数据
- **权限继承**：下级分组的数据自动继承上级分组权限
- **权限范围**：用户权限、分组权限、设备权限、数据权限全部统一

#### 数据权限适用范围（必须全部实现）
- **用户数据权限**：用户列表查询必须按分组过滤
- **分组数据权限**：分组树查询必须按用户权限过滤
- **设备数据权限**：设备列表查询必须按分组过滤
- **设备数据查询权限**：设备数据查询必须按设备所属分组过滤
- **统计数据权限**：统计数据必须按分组过滤
- **告警日志权限**：告警日志必须按设备所属分组过滤
- **命令记录权限**：命令下发记录必须按设备所属分组过滤

#### 统一权限判断逻辑（所有接口必须一致）
1. **获取当前用户**：从Token中解析用户信息
2. **判断超级管理员**：检查用户角色是否为super_admin
3. **获取权限分组列表**：
   - 超级管理员：返回null（表示不过滤）
   - 普通用户：获取用户所属分组ID及所有下级分组ID列表
4. **应用权限过滤**：
   - 使用分组ID列表过滤查询条件
   - 确保只返回权限范围内的数据

#### 权限过滤字段映射（统一规范）
- **用户表**：使用 `group_id` 字段过滤
- **设备表**：使用 `group_id` 字段过滤
- **设备数据表**：通过设备表的 `group_id` 关联过滤
- **分组表**：使用分组ID列表过滤
- **告警日志表**：通过设备表的 `group_id` 关联过滤
- **命令记录表**：通过设备表的 `group_id` 关联过滤

#### 禁止行为（严格禁止）
- ❌ 不同Controller使用不同的数据权限逻辑
- ❌ 硬编码权限判断逻辑
- ❌ 跳过数据权限检查
- ❌ 只检查本分组，不包含下级分组
- ❌ 用户权限、分组权限、设备权限使用不同的判断逻辑
- ❌ 部分接口实现权限，部分接口不实现
- ❌ 权限判断逻辑不一致（如有的用group_id，有的用其他字段）

---

### 3. API接口统一原则 ⚠️⚠️⚠️

**所有接口必须遵循统一规范：**

#### 请求规范
- 统一使用POST方法（除特殊情况如文件下载）
- 统一请求头：Authorization: Bearer {token}
- 统一请求体：JSON格式
- 统一参数命名：驼峰命名法

#### 响应规范
- 统一响应结构：{code, message, data}
- code: 200表示成功，其他表示失败
- message: 成功时返回"success"，失败时返回错误信息
- data: 实际数据，可为null

#### 数据来源规范
- **禁止前端硬编码任何业务数据**
- 菜单权限：从后端 `/api/auth/user-info` 获取
- 分组数据：从后端 `/api/device-groups/tree` 获取
- 产品类型：从后端 `/api/products/list` 获取
- 设备状态：从后端 `/api/devices/list` 获取
- 角色类型：从后端 `/api/roles/list` 获取

#### 禁止行为
- 前端硬编码菜单、权限数据
- 前端硬编码分组数据
- 前端硬编码产品、设备类型
- 前端硬编码状态枚举值
- 前端硬编码角色类型

---

### 4. 分组查询统一原则 ⚠️⚠️⚠️

**分组相关功能必须完全统一，禁止任何形式的重复实现：**

#### 后端分组接口（唯一接口）
- **统一接口**：`POST /api/device-groups/tree`（唯一的分组树接口）
- **统一返回格式**：{code: 200, data: {tree: [...]}}
- **统一权限过滤**：根据用户权限自动过滤分组树（后端统一处理）
- **统一树形结构**：包含id、name、parentId、children等字段（所有场景一致）

#### 前端分组使用（强制统一）
- **统一API方法**：**必须**使用 `frontend/src/api/group.js` 中的 `getGroupTree()` 方法
- **统一组件使用**：
  - **下拉选择场景**：**必须**使用 `GroupSelector` 组件（禁止自己实现）
  - **树形展示场景**：**必须**使用 `GroupTree` 组件（禁止自己实现）
  - **其他场景**：优先使用现有组件，无法满足时先询问用户

#### 分组组件使用规范
- **GroupSelector组件**：用于表单中的分组选择（下拉树选择器）
- **GroupTree组件**：用于页面中的分组树展示（可点击、可操作）
- **组件自动处理**：组件内部自动调用API、自动处理权限、自动格式化数据
- **禁止绕过组件**：任何页面不得直接调用分组API，必须通过组件

#### 严格禁止行为
- ❌ **不同页面重复实现分组查询逻辑**（必须使用统一组件）
- ❌ **不同页面使用不同的分组数据格式**（统一使用组件返回的格式）
- ❌ **直接调用API而不使用统一组件或方法**（禁止直接调用 `/api/device-groups/tree`）
- ❌ **重复实现分组树扁平化逻辑**（组件已处理，禁止重复实现）
- ❌ **自己实现分组选择器**（必须使用GroupSelector组件）
- ❌ **自己实现分组树展示**（必须使用GroupTree组件）
- ❌ **在组件外处理分组数据**（组件已封装所有逻辑）

---

### 5. 后端代码设计原则

#### 代码结构规范
- Controller层：只负责参数校验、调用Service、返回结果
- Service层：业务逻辑处理、事务管理
- Mapper层：数据库操作

#### 代码冗余原则
- **允许合理的代码冗余**，便于后续扩展
- 每个Controller可以有自己的工具方法（如getCurrentUser、isSuperAdmin）
- 但数据权限逻辑必须统一（建议提取为工具类）

#### 扩展性要求
- 代码设计要考虑未来扩展
- 字段设计要有冗余，便于后续添加功能
- 接口设计要考虑版本兼容
- 数据库表设计要考虑未来字段扩展

#### 代码复用
- 相同功能的代码应该复用
- 但不要过度抽象，保持代码可读性
- 工具方法可以适当重复，避免过度依赖

---

### 6. 数据库设计原则

#### 表设计规范
- **易于查询**：合理设计索引，避免全表扫描
- **性能优先**：考虑查询频率，优化表结构
- **字段冗余**：允许合理的字段冗余，提升查询性能
- **分区策略**：时序数据表必须使用分区（按月分区）

#### 索引设计规范
- 外键字段必须建索引
- 查询条件字段必须建索引
- 时间字段必须建索引（用于时间范围查询）
- 组合索引要考虑查询顺序
- 唯一字段必须建唯一索引

#### 字段设计规范
- 主键：统一使用bigint自增ID
- 时间字段：统一使用datetime类型
- 状态字段：统一使用tinyint类型（0/1）
- 文本字段：优先使用varchar，避免使用text（除非必需）
- JSON字段：使用TEXT类型存储JSON数据

#### 约束设计规范
- 外键约束：产品属性、命令表使用CASCADE删除
- 唯一约束：设备编码、用户名等唯一字段必须建唯一索引
- 非空约束：必填字段必须设置NOT NULL
- 默认值：状态字段、时间字段设置合理的默认值

#### 禁止行为
- 过度规范化（导致多表JOIN）
- 缺少必要索引
- 使用不合理的字段类型
- 缺少外键约束（关键表）

---

### 7. 性能优化原则 ⚠️⚠️⚠️

**本项目未使用时序数据库，性能要求高，必须严格遵循：**

#### 数据库性能优化
- **分区表**：时序数据表必须使用分区（按月分区）
- **索引优化**：合理设计索引，避免全表扫描
- **查询优化**：避免N+1查询，使用批量查询
- **数据归档**：定期清理历史数据（保留最近3个月）
- **字段冗余**：允许合理的字段冗余，避免多表JOIN

#### 代码性能优化
- **批量操作**：批量插入、批量更新、批量查询
- **缓存策略**：设备在线状态、最新数据使用Redis缓存
- **异步处理**：MQTT消息处理使用异步，避免阻塞
- **分页查询**：列表查询必须分页，避免一次性加载大量数据
- **连接池**：数据库连接池合理配置

#### 查询性能要求
- 列表查询响应时间 < 500ms
- 单条数据查询响应时间 < 100ms
- 统计数据查询响应时间 < 1s
- 避免全表扫描
- 避免循环中执行数据库操作

#### 禁止行为
- 全表扫描查询
- 大量数据一次性加载
- 循环中执行数据库操作
- 缺少索引的查询条件
- 未分页的列表查询

---

### 8. MQTT消息处理原则 ⚠️⚠️⚠️

**MQTT是核心通信协议，必须严格遵循：**

#### 消息处理规范
- **异步处理**：MQTT消息处理必须异步，避免阻塞
- **幂等性**：消息处理要保证幂等性，避免重复处理
- **错误处理**：消息处理失败要有重试机制和错误日志
- **性能要求**：消息处理要快速，避免消息堆积

#### 设备上报处理
- 接收设备上报数据
- 解析数据格式（ThingsFusion格式）
- 存储设备数据到数据库
- 更新设备在线状态
- 触发告警检查（如果配置了告警）

#### 命令下发处理
- 接收命令下发请求
- 验证设备状态（设备必须在线）
- 通过MQTT发送命令到设备
- 记录命令下发日志
- 等待设备响应（异步）

#### 禁止行为
- 同步处理MQTT消息
- 消息处理失败不记录日志
- 命令下发不验证设备状态
- 消息处理阻塞主线程

---

### 9. 告警管理原则 ⚠️⚠️⚠️

**告警是核心功能，必须严格遵循：**

#### 告警配置规范
- 告警配置存储在设备表的alarm_config字段（JSON格式）
- 支持单设备配置和批量配置
- 告警配置包含：级别、条件、通知人员、堆叠模式
- 告警配置必须关联产品物模型（监控指标）

#### 告警触发规范
- 设备数据上报时触发告警检查
- 根据告警配置判断是否触发告警
- 告警触发后记录告警日志
- 告警通知相关人员（未来扩展）

#### 告警日志规范
- 所有告警必须记录日志
- 告警日志包含：设备信息、告警级别、告警消息、触发时间
- 告警日志支持查询、统计、处理
- 告警日志要支持分页查询

#### 禁止行为
- 告警配置不关联产品物模型
- 告警触发不记录日志
- 告警日志不实现数据权限过滤

---

### 10. 设备状态管理原则 ⚠️⚠️⚠️

**设备状态是实时数据，必须严格管理：**

#### 状态更新规范
- 设备上报数据时更新在线状态
- 设备离线超时后自动更新为离线状态
- 设备状态变化要记录日志（可选）
- 设备状态要缓存到Redis（提升查询性能）

#### 离线检测规范
- 每个设备配置离线超时时间（默认5分钟）
- 定时任务检查设备离线状态
- 设备离线后触发离线告警（如果配置了）
- 设备重新上线后更新状态

#### 状态查询规范
- 设备状态查询优先从Redis获取
- Redis未命中时查询数据库
- 设备状态要实时更新到前端（WebSocket，未来扩展）

#### 禁止行为
- 设备状态不更新
- 设备离线检测不执行
- 设备状态查询不优化

---

### 11. 数据存储原则 ⚠️⚠️⚠️

**设备数据是时序数据，存储要优化：**

#### 数据存储规范
- 设备数据存储在tb_device_data表（分区表）
- 数据按时间分区（按月分区）
- 数据包含：设备ID、设备编码、属性标识、属性值、采集时间、接收时间
- 数据要支持高效的时间范围查询

#### 数据查询规范
- 时间范围查询必须使用索引
- 单设备数据查询要限制时间范围
- 统计数据查询要使用聚合函数
- 历史数据查询要分页

#### 数据归档规范
- 定期清理历史数据（保留最近3个月）
- 归档数据可以导出备份
- 归档数据删除要有日志记录

#### 禁止行为
- 全表扫描查询设备数据
- 不限制时间范围的数据查询
- 一次性加载大量历史数据

---

### 12. 前端组件规范 ⚠️⚠️⚠️

**前端组件要统一、可复用：**

#### 组件使用规范
- 统一使用Element Plus组件库
- 统一使用Vue 3 Composition API（`<script setup>`）
- 统一使用TypeScript类型（如果使用TS）
- 组件要可复用、可配置

#### 组件设计规范
- 组件要有明确的职责
- 组件要有清晰的Props和Events
- 组件要有错误处理
- 组件要有加载状态

#### 全局组件
- GroupSelector：分组选择器组件
- GroupTree：分组树组件
- 其他全局组件要统一管理

#### 禁止行为
- 不同页面重复实现相同功能的组件
- 组件硬编码业务数据
- 组件不处理错误情况

---

### 13. 错误处理原则 ⚠️⚠️⚠️

**错误处理要统一、友好：**

#### 后端错误处理
- 统一异常处理：使用@ControllerAdvice统一处理异常
- 统一错误响应格式：{code, message, data: null}
- 记录错误日志：关键错误要记录日志
- 错误信息要友好：不要暴露系统内部信息

#### 前端错误处理
- 统一错误处理：使用响应拦截器统一处理错误
- 统一错误提示：使用Element Plus的Message组件
- 错误要友好：显示用户友好的错误信息
- 错误要记录：关键错误要记录到控制台

#### 禁止行为
- 错误信息暴露系统内部信息
- 错误不处理直接抛出
- 错误不记录日志

---

### 14. 日志管理原则 ⚠️⚠️⚠️

**日志是问题排查的关键，必须规范：**

#### 日志级别规范
- ERROR：系统错误、异常
- WARN：警告信息、潜在问题
- INFO：关键操作、业务流程
- DEBUG：调试信息（生产环境关闭）

#### 日志内容规范
- 关键操作要记录日志（增删改）
- 错误要记录详细日志（堆栈信息）
- 性能关键点要记录日志（耗时）
- 用户操作要记录日志（操作日志表）

#### 日志格式规范
- 统一日志格式：时间、级别、类名、消息
- 日志要包含关键信息：用户ID、设备ID、操作类型
- 日志要结构化：便于日志分析

#### 禁止行为
- 关键操作不记录日志
- 错误不记录详细日志
- 日志格式不统一

---

### 15. 安全规范 ⚠️⚠️⚠️

**安全是系统的基础，必须严格遵循：**

#### 认证授权规范
- 所有接口必须验证Token
- Token过期要重新登录
- 权限验证要严格，不能绕过

#### 数据安全规范
- 密码要加密存储
- 敏感数据要加密传输
- SQL注入防护：使用参数化查询
- XSS防护：前端输入要过滤

#### 接口安全规范
- 接口要验证参数
- 接口要限制请求频率（防止攻击）
- 接口要记录操作日志

#### 禁止行为
- 接口不验证Token
- 密码明文存储
- SQL注入漏洞
- XSS漏洞

---

## 🚫 禁止行为清单

### 后端禁止行为
- 修改后端代码前不询问用户
- 不同Controller使用不同的数据权限逻辑
- 硬编码权限判断逻辑
- 跳过数据权限检查
- 返回格式不统一
- 全表扫描查询
- 循环中执行数据库操作
- 同步处理MQTT消息
- 告警触发不记录日志
- 设备状态不更新

### 前端禁止行为
- 硬编码菜单、权限数据
- 硬编码分组数据
- 硬编码产品、设备类型
- 不同页面重复实现分组查询逻辑
- 直接调用API而不使用统一组件
- 组件硬编码业务数据
- 错误不处理

---

## ✅ 必须遵守的规则

### 1. 修改后端前必须询问
```
⚠️ 重要：需要修改后端代码时，必须先询问用户：
"需要修改后端代码 [具体文件和方法]，是否同意？"
```

### 2. 数据权限必须全局统一
```
⚠️ 所有查询接口必须实现数据权限过滤，使用完全一致的逻辑。
⚠️ 用户数据权限、分组数据权限、设备数据权限必须统一实现。
⚠️ 所有权限判断逻辑必须一致，禁止不同接口使用不同的权限逻辑。
```

### 3. 接口数据必须从后端获取
```
⚠️ 前端禁止硬编码任何业务数据，必须从后端API获取。
```

### 4. 分组查询必须完全统一
```
⚠️ 前端必须使用统一的组件获取分组数据，禁止任何形式的重复实现。
⚠️ 下拉选择场景必须使用GroupSelector组件，树形展示必须使用GroupTree组件。
⚠️ 禁止直接调用分组API，禁止自己实现分组选择器或分组树。
```

### 5. 性能优先
```
⚠️ 本项目未使用时序数据库，代码设计必须考虑性能。
```

### 6. MQTT消息异步处理
```
⚠️ MQTT消息处理必须异步，避免阻塞。
```

### 7. 告警必须记录日志
```
⚠️ 所有告警必须记录日志，支持查询和统计。
```

### 8. 设备状态实时更新
```
⚠️ 设备状态要实时更新，离线检测要定时执行。
```

---

## 📚 参考文件

### 关键文件位置
- 数据库初始化：`init.sql`
- 前端API封装：`frontend/src/api/group.js`
- 前端请求封装：`frontend/src/utils/request.js`
- 分组组件：`frontend/src/components/GroupSelector.vue`、`GroupTree.vue`
- 数据权限示例：`backend/src/main/java/com/iot/platform/controller/DeviceController.java`
- MQTT配置：`backend/src/main/java/com/iot/platform/mqtt/MqttConfig.java`

### 参考实现
- 数据权限实现：参考DeviceController.getDeviceList()方法
- 分组树实现：参考DeviceGroupController.getGroupTree()方法
- 前端分组使用：参考GroupSelector.vue组件
- MQTT消息处理：参考MqttMessageHandler.java

---

## 🎯 开发流程规范

### 1. 需求分析
- 理解需求
- 确定修改范围（前端/后端）
- 如需修改后端，先询问用户
- 考虑性能影响
- 考虑数据权限

### 2. 代码实现
- 遵循统一规范
- 实现数据权限（后端）
- 使用统一组件/方法（前端）
- 考虑性能优化
- 考虑错误处理

### 3. 代码检查
- 检查是否遵循规范
- 检查数据权限是否实现
- 检查性能是否优化
- 检查是否有硬编码
- 检查错误处理是否完善

---

## 📌 特别提醒

### 对于AI助手
1. **修改后端前必须询问用户**
2. **优先修改前端解决问题**
3. **保持代码一致性**
4. **遵循统一规范**
5. **考虑性能优化**
6. **考虑数据权限**
7. **考虑MQTT消息处理**
8. **考虑告警管理**

### 对于开发者
1. **阅读本文档后再开发**
2. **遵循统一规范**
3. **保持代码一致性**
4. **定期更新本文档**

---

## 💡 代码简洁性原则

### 代码简洁性要求
- **在实现功能要求的前提下，代码越简单越好**
- **代码注释要详细**，关键逻辑、复杂算法、业务规则必须添加注释
- **避免过度设计**，不要为了展示技术而增加复杂度
- **优先使用简单直接的实现方式**，除非性能或业务有特殊要求

### 注释规范
- **方法注释**：说明方法功能、参数含义、返回值含义
- **业务逻辑注释**：复杂业务逻辑必须添加注释说明
- **算法注释**：复杂算法必须添加注释说明思路
- **TODO注释**：临时方案、待优化代码要添加TODO注释
- **关键代码注释**：数据权限判断、权限过滤等关键代码必须注释

### 禁止行为
- ❌ 为了展示技术而增加不必要的复杂度
- ❌ 过度抽象导致代码难以理解
- ❌ 关键逻辑没有注释
- ❌ 复杂业务逻辑没有注释说明

---

*最后更新：2025-01-XX*
