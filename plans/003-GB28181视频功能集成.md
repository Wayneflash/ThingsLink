# GB28181视频功能集成方案

> **功能描述**：集成WVP平台，实现GB28181视频设备的实时播放功能
> **创建时间**：2026-01-13
> **状态**：方案设计阶段

---

## 📋 功能概述

基于已部署的WVP（Web Video Platform）平台，在IoT平台中集成GB28181视频功能，实现视频设备的实时播放。

---

## 🔌 WVP API接口梳理

### 基础信息

- **Base URL**：待确认（用户提供）
- **认证方式**：Token认证（通过登录接口获取accessToken）
- **Token使用**：所有接口需要在Header中携带 `access-token: {token}`

---

### 1. 登录接口

**接口路径**：`GET /api/user/login`

**请求参数**：
| 参数名 | 位置 | 类型 | 必选 | 说明 |
|--------|------|------|------|------|
| username | query | string | 是 | 用户名 |
| password | query | string | 是 | 密码（需要MD5 32位小写加密） |

**请求示例**：
```
GET /api/user/login?username=admin&password={md5加密后的密码}
```

**响应格式**：
```json
{
  "code": 0,
  "msg": "string",
  "data": {
    "accessToken": "string",          // 核心：后续接口的认证Token
    "id": 0,
    "enabled": true,
    "username": "string",
    "role": {
      "id": 0,
      "name": "string",
      "authority": "string"
    },
    "pushKey": "string"
  }
}
```

**关键字段说明**：
- `accessToken`：用于后续所有接口的认证，需要在Header中传递
- `code`：0表示成功，其他值表示失败
- `msg`：返回消息

---

### 2. 查询设备状态接口

**接口路径**：`GET /api/device/query/devices/{deviceId}`

**请求参数**：
| 参数名 | 位置 | 类型 | 必选 | 说明 |
|--------|------|------|------|------|
| deviceId | path | string | 是 | 设备ID（GB28181设备编码） |
| access-token | header | string | 是 | 登录获取的Token |

**请求示例**：
```
GET /api/device/query/devices/340200000013202274845
Headers: access-token: {token}
```

**响应格式**：
```json
{
  "id": 0,                              // 设备数据库ID
  "deviceId": "string",                 // 设备ID（GB28181设备编码）
  "name": "string",                     // 设备名称
  "manufacturer": "string",             // 厂商
  "model": "string",                    // 型号
  "firmware": "string",                 // 固件版本
  "transport": "string",                // 传输协议（UDP/TCP）
  "streamMode": "string",               // 流模式
  "ip": "string",                       // 设备IP地址
  "port": 0,                            // 设备端口
  "hostAddress": "string",              // 主机地址
  "onLine": true,                       // 是否在线（核心字段）
  "registerTime": "string",             // 注册时间
  "keepaliveTime": "string",            // 心跳时间
  "heartBeatInterval": 0,               // 心跳间隔（秒）
  "heartBeatCount": 0,                  // 心跳计数
  "positionCapability": 0,              // 位置能力
  "channelCount": 0,                    // 通道数量（核心字段）
  "expires": 0,                         // 过期时间
  "createTime": "string",               // 创建时间
  "updateTime": "string",               // 更新时间
  "mediaServerId": "string",            // 媒体服务器ID
  "charset": "string",                  // 字符集
  "subscribeCycleForCatalog": 0,        // 目录订阅周期
  "subscribeCycleForMobilePosition": 0, // 移动位置订阅周期
  "mobilePositionSubmissionInterval": 0,// 移动位置提交间隔
  "subscribeCycleForAlarm": 0,          // 告警订阅周期
  "ssrcCheck": true,                    // SSRC检查
  "geoCoordSys": "string",              // 地理坐标系统
  "password": "string",                 // 密码
  "sdpIp": "string",                    // SDP IP
  "localIp": "string",                  // 本地IP
  "asMessageChannel": true,             // 作为消息通道
  "sipTransactionInfo": {               // SIP事务信息
    "callId": "string",
    "fromTag": "string",
    "toTag": "string",
    "viaBranch": "string",
    "asSender": true
  },
  "broadcastPushAfterAck": true         // 确认后广播推送
}
```

**关键字段说明**：
- `deviceId`：GB28181设备编码（20位数字）
- `name`：设备名称
- `onLine`：设备在线状态（true=在线，false=离线）
- `ip` / `port`：设备IP和端口
- `channelCount`：通道数量（用于显示设备有多少个视频通道）
- `registerTime`：设备注册时间
- `keepaliveTime`：最后心跳时间
- `transport`：传输协议（UDP/TCP）

---

### 3. 实时播放接口（核心接口）⭐

**接口路径**：`GET /api/play/start/{deviceId}/{channelId}`

**请求参数**：
| 参数名 | 位置 | 类型 | 必选 | 说明 |
|--------|------|------|------|------|
| deviceId | path | string | 是 | 设备ID（GB28181设备编码） |
| channelId | path | string | 是 | 通道ID（GB28181通道编码） |
| access-token | header | string | 是 | 登录获取的Token |

**请求示例**：
```
GET /api/play/start/340200000013202274845/34020000001310000001
Headers: access-token: {token}
```

**响应格式**：
```json
{
  "code": 0,
  "msg": "string",
  "data": {
    // ===== 流媒体地址（核心数据） =====
    "app": "string",                    // 应用名
    "stream": "string",                 // 流ID
    "ip": null,                         // IP地址
    
    // FLV格式
    "flv": "string",                    // HTTP FLV地址
    "https_flv": "string",              // HTTPS FLV地址
    "ws_flv": "string",                 // WebSocket FLV地址
    "wss_flv": "string",                // WebSocket Secure FLV地址
    
    // HLS格式
    "hls": "string",                    // HTTP HLS地址（.m3u8）
    "https_hls": "string",              // HTTPS HLS地址
    "ws_hls": "string",                 // WebSocket HLS地址
    "wss_hls": "string",                // WebSocket Secure HLS地址
    
    // RTMP格式
    "rtmp": "string",                   // RTMP地址
    "rtmps": null,                      // RTMPS地址
    
    // RTSP格式
    "rtsp": "string",                   // RTSP地址
    "rtsps": null,                      // RTSPS地址
    
    // RTC格式（WebRTC）
    "rtc": "string",                    // RTC地址
    "rtcs": "string",                   // RTC Secure地址
    
    // FMP4格式
    "fmp4": "string",
    "https_fmp4": "string",
    "ws_fmp4": "string",
    "wss_fmp4": "string",
    
    // TS格式
    "ts": "string",
    "https_ts": "string",
    "ws_ts": "string",
    "wss_ts": null,
    
    // ===== 媒体服务器信息 =====
    "mediaServerId": "string",          // 媒体服务器ID
    
    // ===== 流媒体详细信息 =====
    "mediaInfo": {
      "app": "string",
      "stream": "string",
      
      // 媒体服务器配置
      "mediaServer": {
        "id": "string",
        "ip": "string",                 // 服务器IP
        "httpPort": 0,                  // HTTP端口
        "httpSSlPort": 0,               // HTTPS端口
        "rtmpPort": 0,                  // RTMP端口
        "flvPort": 0,                   // FLV端口
        "rtspPort": 0,                  // RTSP端口
        "status": true,                 // 服务器状态
        "type": "string"                // 服务器类型
      },
      
      // 视频编码信息
      "videoCodec": "string",           // 视频编码格式（如：H264）
      "width": 0,                       // 视频宽度（像素）
      "height": 0,                      // 视频高度（像素）
      "fps": null,                      // 帧率
      "loss": null,                     // 丢包率
      
      // 音频编码信息
      "audioCodec": null,               // 音频编码格式
      "audioChannels": null,            // 音频声道数
      "audioSampleRate": null,          // 音频采样率
      
      // 流状态信息
      "online": true,                   // 是否在线
      "readerCount": 0,                 // 观看人数
      "aliveSecond": 0,                 // 存活时长（秒）
      "bytesSpeed": 0,                  // 字节速度
      "callId": "string",               // 呼叫ID
      "originUrl": "string",            // 原始URL
      "serverId": "string"              // 服务器ID
    },
    
    // ===== 其他信息 =====
    "startTime": null,                  // 开始时间
    "endTime": null,                    // 结束时间
    "progress": 0                       // 进度
  }
}
```

**关键返回字段说明**：

1. **流媒体地址（用于前端播放）**：
   - `flv` / `https_flv` / `ws_flv` / `wss_flv`：FLV格式，适合HTTP/WebSocket播放
   - `hls` / `https_hls` / `ws_hls` / `wss_hls`：HLS格式（.m3u8），适合HTML5播放
   - `rtmp` / `rtmps`：RTMP格式，需要Flash播放器（已淘汰）
   - `rtsp` / `rtsps`：RTSP格式，需要专用播放器
   - `rtc` / `rtcs`：WebRTC格式，适合低延迟实时播放

2. **视频编码信息**：
   - `videoCodec`：视频编码格式（通常为H264）
   - `width` / `height`：视频分辨率
   - `fps`：帧率
   - `online`：流是否在线

3. **推荐使用的流格式**：
   - **Web播放（推荐）**：`ws_flv`（WebSocket FLV）或 `hls`（HLS）
   - **低延迟**：`rtc`（WebRTC）
   - **兼容性最好**：`hls`（HLS，支持HTML5 video标签）

---

## 🔑 认证流程

### 1. 登录获取Token

```
1. 用户输入用户名和密码
2. 将密码进行MD5 32位小写加密
3. 调用登录接口：GET /api/user/login?username={username}&password={md5_password}
4. 获取返回的 accessToken
5. 将 accessToken 保存（用于后续接口调用）
```

### 2. 调用其他接口

```
1. 在请求Header中携带Token
   Header: access-token: {accessToken}
2. 调用目标接口（如实时播放接口）
3. 如果Token过期，需要重新登录获取新Token
```

---

## 💡 技术实现要点

### 1. MD5加密（密码加密）

- **算法**：MD5
- **格式**：32位小写十六进制字符串
- **示例**：
  - 原文：`wangyq`
  - MD5：`8f3e8b5c4a9d2e7f1b6c3d8a5e2f9c1b`（32位小写）

### 2. Token管理

- **存储位置**：后端存储（Redis或内存），前端不直接存储
- **过期处理**：Token过期时，自动重新登录获取新Token
- **使用方式**：所有WVP接口调用时，在Header中携带 `access-token`

### 3. 前端播放器选择（性能对比分析）

#### 各流格式对比表

| 流格式 | 延迟 | 服务器压力 | 实现难度 | 兼容性 | 适用场景 |
|--------|------|------------|----------|--------|----------|
| **HLS (hls)** | 3-10秒 | ⭐ 最小 | ⭐⭐ 简单 | ⭐⭐⭐⭐⭐ 最好 | **推荐：多路并发、性能优先** |
| **WebSocket FLV (ws_flv)** | 1-3秒 | ⭐⭐⭐ 中等 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐ 好 | 低延迟场景 |
| **HTTP FLV (flv)** | 1-3秒 | ⭐⭐⭐⭐ 较大 | ⭐⭐ 简单 | ⭐⭐⭐ 一般 | 不推荐（需要HTTP长连接） |
| **WebRTC (rtc)** | <1秒 | ⭐⭐⭐⭐⭐ 最大 | ⭐⭐⭐⭐ 复杂 | ⭐⭐⭐ 一般 | 极低延迟（单路或少路） |
| **RTMP (rtmp)** | 1-2秒 | ⭐⭐⭐⭐ 较大 | ⭐⭐ 简单 | ⭐ 差（需Flash） | 已淘汰，不推荐 |

#### 服务器性能分析

**HLS格式（推荐⭐⭐⭐⭐⭐）**
- **服务器压力**：最小
  - 基于HTTP GET请求，服务器只需切片存储
  - 客户端按需下载切片文件（类似静态文件分发）
  - 支持CDN加速，可大幅降低服务器负载
  - 无需维持长连接，服务器资源占用少
- **延迟**：3-10秒（取决于切片时长，通常6秒）
- **实现**：HTML5 video标签原生支持，无需额外库
- **适用**：**多路视频并发播放场景**（如监控大屏、多画面）

**WebSocket FLV格式**
- **服务器压力**：中等
  - 需要维持WebSocket长连接
  - 每个播放器一个连接，10路视频=10个连接
  - 服务器需要实时推流，CPU和内存占用较高
- **延迟**：1-3秒
- **实现**：需要引入flv.js库（约150KB）
- **适用**：对延迟要求较高的场景（如实时监控）

**WebRTC格式**
- **服务器压力**：最大
  - 点对点传输，需要大量CPU和带宽
  - 不适合多路并发（10路以上服务器压力巨大）
- **延迟**：<1秒（最低）
- **实现**：需要WebRTC API，兼容性一般
- **适用**：单路或少路低延迟场景（如视频通话）

#### 最终推荐

**🏆 推荐方案：HLS格式 (`hls` 或 `https_hls`)**

**理由**：
1. **服务器性能要求最小** ⭐⭐⭐⭐⭐
   - 静态文件分发模式，服务器压力最小
   - 支持CDN，可进一步降低服务器负载
   - 适合多路并发（100路+也能稳定运行）

2. **实现简单** ⭐⭐⭐⭐⭐
   - HTML5 video标签原生支持，无需额外库
   - 代码简洁，维护成本低

3. **兼容性最好** ⭐⭐⭐⭐⭐
   - 所有现代浏览器支持（Chrome、Firefox、Safari、Edge）
   - 移动端支持良好（iOS、Android）

4. **延迟可接受** ⭐⭐⭐
   - 3-10秒延迟对于监控场景通常可接受
   - 可通过调整切片时长降低延迟（最低可到2-3秒）

**代码示例**：
```html
<video controls autoplay>
  <source src="{hls_url}" type="application/x-mpegURL">
</video>
```

**备选方案**：如果对延迟要求很高（<3秒），可考虑 `ws_flv`（WebSocket FLV），但需要引入flv.js库，且服务器压力会增加。

---

### 4. HLS (HTTPS) vs FLV 详细对比

#### 对比表格

| 对比项 | **HLS (https_hls)** | **FLV (wss_flv / https_flv)** |
|--------|---------------------|------------------------------|
| **延迟** | 3-10秒（通常6秒） | 1-3秒 |
| **服务器压力** | ⭐ 最小（静态文件分发） | ⭐⭐⭐ 中等（需要维持连接） |
| **实现难度** | ⭐⭐ 非常简单 | ⭐⭐⭐ 中等 |
| **代码量** | 几行HTML即可 | 需要引入flv.js库（~150KB） |
| **浏览器支持** | ⭐⭐⭐⭐⭐ 完美（原生支持） | ⭐⭐⭐⭐ 好（需要flv.js） |
| **移动端支持** | ⭐⭐⭐⭐⭐ 完美（iOS/Android原生） | ⭐⭐⭐ 一般（需要额外处理） |
| **多路并发** | ⭐⭐⭐⭐⭐ 优秀（100路+无压力） | ⭐⭐⭐ 中等（10-20路较合适） |
| **稳定性** | ⭐⭐⭐⭐⭐ 非常稳定 | ⭐⭐⭐⭐ 较稳定 |
| **资源占用** | 低（客户端按需下载） | 中等（需要实时解码） |
| **适用场景** | 监控大屏、多画面、稳定性优先 | 低延迟监控、单路或少路播放 |

#### 详细分析

**HLS (HTTPS) - 推荐⭐⭐⭐⭐⭐**

✅ **优势**：
1. **实现最简单**：HTML5 video标签原生支持，无需任何库
   ```html
   <video controls autoplay>
     <source src="https://.../hls.m3u8" type="application/x-mpegURL">
   </video>
   ```
2. **服务器压力最小**：基于HTTP GET请求，类似静态文件分发
3. **多路并发优秀**：100路视频同时播放，服务器压力也很小
4. **移动端完美支持**：iOS Safari和Android Chrome原生支持
5. **稳定性最好**：自动重连、缓冲机制完善
6. **无需额外依赖**：项目体积不增加

❌ **劣势**：
- 延迟较高（3-10秒），对实时性要求极高的场景不太适合

**FLV (WSS/HTTPS) - 备选方案⭐⭐⭐⭐**

✅ **优势**：
1. **延迟低**：1-3秒，接近实时
2. **画质稳定**：实时流传输，画质更稳定

❌ **劣势**：
1. **需要引入flv.js库**（~150KB），增加项目体积
2. **服务器压力较大**：需要维持WebSocket长连接，每路视频一个连接
3. **多路并发有限制**：10-20路视频时服务器压力就比较大
4. **移动端支持一般**：需要额外处理，可能有问题
5. **代码复杂度高**：需要初始化flv.js，处理错误重连等

**代码对比**：

**HLS实现（超简单）**：
```html
<video controls autoplay muted style="width: 100%">
  <source src="https://lxs.fjqiaolong.com:8443/rtp/.../hls.m3u8" type="application/x-mpegURL">
</video>
```

**FLV实现（需要flv.js）**：
```html
<video ref="videoElement" controls autoplay muted style="width: 100%"></video>

<script>
import flvjs from 'flv.js'

const flvPlayer = flvjs.createPlayer({
  type: 'flv',
  url: 'wss://lxs.fjqiaolong.com:8443/rtp/.../live.flv'
})
flvPlayer.attachMediaElement(videoElement.value)
flvPlayer.load()
flvPlayer.play()
</script>
```

#### 最终推荐

**🏆 推荐：HLS (https_hls) ⭐⭐⭐⭐⭐**

**理由**：
1. ✅ **您已经测试可用**：HTTPS HLS地址可以正常播放
2. ✅ **实现最简单**：HTML5原生支持，几行代码搞定
3. ✅ **服务器性能最好**：适合多路视频并发场景
4. ✅ **稳定性最高**：自动缓冲、重连机制完善
5. ✅ **移动端完美**：iOS和Android原生支持
6. ✅ **无额外依赖**：不需要引入flv.js，项目更轻量

**延迟问题**：
- 3-10秒延迟对于监控场景通常**完全可接受**
- 大多数监控系统都使用HLS，延迟不是问题
- 如果真的需要低延迟，再考虑FLV

**建议**：
- **首选**：使用 `https_hls`（您已经测试可用的地址）
- **备选**：如果后续需要更低延迟，再考虑 `wss_flv`

---

## 📝 待确认事项

1. **WVP服务地址**：
   - Base URL（如：`http://192.168.x.x:18080`）
   - 是否需要配置到系统配置中？

2. **WVP登录账号**：
   - 用户名
   - 密码（需要MD5加密）

3. **设备ID和通道ID**：
   - 设备ID格式：GB28181设备编码（20位数字）
   - 通道ID格式：GB28181通道编码（20位数字）
   - 数据来源：是否需要从IoT平台的设备表中获取？

4. **Token过期时间**：
   - Token有效期多久？
   - 是否需要实现Token自动刷新机制？

5. **前端播放器**：
   - 选择哪种播放格式？（推荐：ws_flv或hls）
   - 是否需要支持多路视频同时播放？

---

## 🎯 下一步计划

1. **确认WVP配置信息**（Base URL、登录账号）
2. **设计页面UI**（用户描述页面元素和布局）
3. **后端API开发**（WVP接口封装、Token管理）
4. **前端页面开发**（视频播放页面、播放器集成）
5. **测试验证**（接口调用、视频播放测试）

---

## 📌 接口总结

| 接口 | 方法 | 路径 | 认证 | 说明 |
|------|------|------|------|------|
| 登录 | GET | /api/user/login | 否 | 获取accessToken（密码需MD5加密） |
| 查询设备状态 | GET | /api/device/query/devices/{deviceId} | 是 | 查询设备状态 |
| 实时播放 | GET | /api/play/start/{deviceId}/{channelId} | 是 | 获取视频流地址（核心接口） |

---

*最后更新：2026-01-13*
