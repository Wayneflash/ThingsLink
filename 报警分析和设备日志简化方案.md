# 设备日志功能方案

## 一、需求分析

### 1.1 功能需求
```
在命令控制Tab后面添加一个Tab：
设备日志Tab - 显示设备状态变化日志，格式：类型、详情
```

### 1.2 日志格式
```
统一格式：
- 类型：日志类型（如：设备上线、设备离线、命令下发）
- 详情：日志详情（如：设备上线、设备离线、命令下发成功）
```

---

## 二、Tab页结构

### 2.1 Tab页布局
```
[实时数据] [历史数据] [命令控制] [设备日志]
```

---

## 三、设备日志Tab设计

### 3.1 功能描述
```
显示设备的各种状态变化日志，包括：
1. 设备上线/离线日志
2. 命令下发日志
```

### 3.2 日志类型
```
设备上线：设备从离线变为在线
设备离线：设备从在线变为离线
命令下发：下发命令到设备
```

### 3.3 日志列表
```
┌─────────────────────────────────────────────────────────┐
│  时间                │ 类型        │ 详情        │
├─────────────────────────────────────────────────────────┤
│  2025-01-10 22:30:00 │ 设备上线    │ 设备上线     │
│  2025-01-10 22:15:00 │ 命令下发    │ 命令下发成功 │
│  2025-01-10 22:10:00 │ 设备离线    │ 设备离线     │
└─────────────────────────────────────────────────────────┘
```

### 3.4 筛选功能
```
筛选条件：
1. 日志类型：全部、设备上线、设备离线、命令下发
2. 时间范围：今日、昨日、最近7天、最近30天、自定义
```

### 3.5 UI设计
```
┌─────────────────────────────────────────────────────────┐
│  设备日志                                              │
├─────────────────────────────────────────────────────────┤
│  筛选条件：                                            │
│  日志类型：[全部▼] 时间范围：[今日▼]              │
│                                                         │
│  日志列表：                                            │
│  ┌─────────────────────────────────────────────┐   │
│  │ 时间                │ 类型    │ 详情  │   │
│  ├─────────────────────────────────────────────┤   │
│  │ 22:30:00 │ 设备上线 │ 设备上线 │   │
│  │ 22:15:00 │ 命令下发 │ 命令下发成功 │   │
│  │ 22:10:00 │ 设备离线 │ 设备离线 │   │
│  └─────────────────────────────────────────────┘   │
│                                                         │
│  分页器：[上一页] [1] [2] [3] [下一页]              │
└─────────────────────────────────────────────────────────┘
```

---

## 四、技术实现

### 4.1 前端技术栈
```
核心框架：
- Vue 3 + JavaScript
- Element Plus（UI组件）
- Axios（HTTP请求）

实现位置：
- 在 DeviceDetail.vue 中新增设备日志Tab内容区域
```

### 4.2 后端技术栈
```
核心框架：
- Spring Boot 2.7
- MyBatis Plus
- MQTT（设备数据接收）

新增API接口：
- POST /api/device-logs - 获取设备日志列表（新增）
```

### 4.3 数据库设计

#### 4.3.1 新增表：device_log（设备日志）
```sql
CREATE TABLE `device_log` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `device_id` bigint NOT NULL COMMENT '设备ID',
  `device_code` varchar(64) NOT NULL COMMENT '设备编码',
  `log_type` varchar(32) NOT NULL COMMENT '日志类型：online-设备上线, offline-设备离线, command-命令下发',
  `log_detail` varchar(255) DEFAULT NULL COMMENT '日志详情',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_device_id` (`device_id`),
  KEY `idx_device_code` (`device_code`),
  KEY `idx_log_type` (`log_type`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='设备日志表';
```

### 4.4 后端实现方案

#### 4.4.1 设备日志记录机制

**触发时机：**
1. 设备上报数据时，检测到状态变化（离线→在线）时记录"设备上线"日志
2. 定时任务检测到设备超时（在线→离线）时记录"设备离线"日志
3. 命令下发成功后记录"命令下发"日志

**实现位置：**
1. `DeviceService.refreshHeartbeat()` - 检测设备上线
2. `DeviceStatusCheckTask` - 检测设备离线
3. `CommandController.sendCommand()` - 记录命令下发

#### 4.4.2 设备上线日志记录

**修改位置：** [`DeviceService.refreshHeartbeat()`](backend/src/main/java/com/iot/platform/service/DeviceService.java:270-282)

**实现逻辑：**
```java
public void refreshHeartbeat(String deviceCode) {
    Device device = getByDeviceCode(deviceCode);
    if (device != null) {
        // 设备心跳，3分钟超时
        String key = DEVICE_ONLINE_KEY + deviceCode;
        stringRedisTemplate.opsForValue().set(key, "1", 180, TimeUnit.SECONDS);
        
        // 如果设备状态是离线，更新为在线
        if (device.getStatus() == 0) {
            updateOnlineStatus(deviceCode, true);
            
            // 记录设备上线日志
            recordDeviceLog(device.getId(), deviceCode, "online", "设备上线");
        }
    }
}

/**
 * 记录设备日志
 */
private void recordDeviceLog(Long deviceId, String deviceCode, String logType, String logDetail) {
    try {
        DeviceLog deviceLog = new DeviceLog();
        deviceLog.setDeviceId(deviceId);
        deviceLog.setDeviceCode(deviceCode);
        deviceLog.setLogType(logType);
        deviceLog.setLogDetail(logDetail);
        deviceLog.setCreateTime(LocalDateTime.now());
        deviceLogService.save(deviceLog);
    } catch (Exception e) {
        log.error("记录设备日志失败 - 设备: {}", deviceCode, e);
    }
}
```

#### 4.4.3 设备离线日志记录

**修改位置：** `DeviceStatusCheckTask`

**实现逻辑：**
```java
@Component
public class DeviceStatusCheckTask {
    
    @Resource
    private DeviceService deviceService;
    
    @Resource
    private DeviceLogService deviceLogService;
    
    /**
     * 定时检查设备状态（每分钟执行一次）
     */
    @Scheduled(cron = "0 * * * * ?")
    public void checkDeviceStatus() {
        // 获取所有在线设备
        LambdaQueryWrapper<Device> query = new LambdaQueryWrapper<>();
        query.eq(Device::getStatus, 1);
        List<Device> onlineDevices = deviceService.list(query);
        
        // 检查每个设备的在线状态
        for (Device device : onlineDevices) {
            String key = "device:online:" + device.getDeviceCode();
            Boolean isOnline = stringRedisTemplate.opsForValue().get(key) != null;
            
            // 如果Redis中没有在线记录，说明设备已超时离线
            if (!isOnline) {
                // 更新设备状态为离线
                deviceService.updateOnlineStatus(device.getDeviceCode(), false);
                
                // 记录设备离线日志
                recordDeviceLog(device.getId(), device.getDeviceCode(), "offline", "设备离线");
            }
        }
    }
    
    /**
     * 记录设备日志
     */
    private void recordDeviceLog(Long deviceId, String deviceCode, String logType, String logDetail) {
        try {
            DeviceLog deviceLog = new DeviceLog();
            deviceLog.setDeviceId(deviceId);
            deviceLog.setDeviceCode(deviceCode);
            deviceLog.setLogType(logType);
            deviceLog.setLogDetail(logDetail);
            deviceLog.setCreateTime(LocalDateTime.now());
            deviceLogService.save(deviceLog);
        } catch (Exception e) {
            log.error("记录设备日志失败 - 设备: {}", deviceCode, e);
        }
    }
}
```

#### 4.4.4 命令下发日志记录

**修改位置：** [`CommandController.sendCommand()`](backend/src/main/java/com/iot/platform/controller/CommandController.java:68-102)

**实现逻辑：**
```java
@PostMapping("/send")
public Result<Map<String, Object>> sendCommand(@RequestBody SendCommandRequest request) {
    try {
        log.info("接收到命令下发请求 - 设备: {}, 命令数量: {}", 
                request.getDeviceCode(), request.getCommands() != null ? request.getCommands().size() : 0);
        
        if (request.getCommands() == null || request.getCommands().isEmpty()) {
            return Result.error("命令列表不能为空");
        }
        
        // 获取设备信息
        Device device = deviceService.getByDeviceCode(request.getDeviceCode());
        if (device == null) {
            return Result.error("设备不存在");
        }
        
        // 生成命令唯一ID
        String commandId = "CMD" + System.currentTimeMillis();
        
        // 批量下发命令到MQTT（不等待设备响应）
        for (CommandItem cmd : request.getCommands()) {
            mqttPublisher.sendCommand(request.getDeviceCode(), cmd.getAddr(), cmd.getAddrv());
        }
        
        // 记录命令下发日志
        try {
            DeviceLog deviceLog = new DeviceLog();
            deviceLog.setDeviceId(device.getId());
            deviceLog.setDeviceCode(request.getDeviceCode());
            deviceLog.setLogType("command");
            deviceLog.setLogDetail("命令下发成功");
            deviceLog.setCreateTime(LocalDateTime.now());
            deviceLogService.save(deviceLog);
        } catch (Exception e) {
            log.error("记录设备日志失败", e);
        }
        
        // 立即返回下发成功响应
        Map<String, Object> data = new HashMap<>();
        data.put("commandId", commandId);
        data.put("status", "已下发");
        data.put("deviceCode", request.getDeviceCode());
        data.put("sendTime", LocalDateTime.now().format(FORMATTER));
        data.put("message", "命令已通过MQTT下发到设备，设备收到后会自行执行");
        
        log.info("命令下发成功 - CommandId: {}, 设备: {}", commandId, request.getDeviceCode());
        
        return Result.success(data, "success");
        
    } catch (Exception e) {
        log.error("命令下发失败 - 设备: {}", request.getDeviceCode(), e);
        return Result.error("命令下发失败: " + e.getMessage());
    }
}
```

#### 4.4.5 设备日志API接口

**新增Controller：** `DeviceLogController`

```java
package com.iot.platform.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.iot.platform.common.Result;
import com.iot.platform.entity.Device;
import com.iot.platform.entity.DeviceLog;
import com.iot.platform.entity.User;
import com.iot.platform.service.DeviceLogService;
import com.iot.platform.service.DeviceService;
import com.iot.platform.util.PermissionUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

import javax.annotation.Resource;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;

/**
 * 设备日志控制器
 */
@Slf4j
@RestController
@RequestMapping("/device-logs")
public class DeviceLogController {
    
    @Resource
    private DeviceLogService deviceLogService;
    
    @Resource
    private DeviceService deviceService;
    
    @Resource
    private PermissionUtil permissionUtil;
    
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    /**
     * 分页查询设备日志
     */
    @PostMapping("/list")
    public Result<Map<String, Object>> getDeviceLogList(@RequestHeader("Authorization") String token,
                                                      @RequestBody Map<String, Object> params) {
        try {
            // 获取当前用户信息
            User currentUser = permissionUtil.getCurrentUser(token);
            if (currentUser == null) {
                return Result.error("用户未登录");
            }
            
            // 获取查询参数
            int page = params.get("page") != null ? (int) params.get("page") : 1;
            int pageSize = params.get("pageSize") != null ? (int) params.get("pageSize") : 20;
            String deviceCode = (String) params.get("deviceCode");
            String logType = (String) params.get("logType");
            String startTimeStr = (String) params.get("startTime");
            String endTimeStr = (String) params.get("endTime");
            
            // 解析时间参数
            LocalDateTime startTime = null;
            LocalDateTime endTime = null;
            if (startTimeStr != null && !startTimeStr.isEmpty()) {
                startTime = LocalDateTime.parse(startTimeStr, FORMATTER);
            }
            if (endTimeStr != null && !endTimeStr.isEmpty()) {
                endTime = LocalDateTime.parse(endTimeStr, FORMATTER);
            }
            
            // 数据权限过滤：获取用户有权限查看的设备ID列表
            List<Long> allowedGroupIds = permissionUtil.getAllowedGroupIds(currentUser);
            List<Long> allowedDeviceIds = null;
            
            if (allowedGroupIds != null) {
                // 普通用户：获取权限范围内的所有设备ID
                LambdaQueryWrapper<Device> deviceQuery = new LambdaQueryWrapper<>();
                deviceQuery.in(Device::getGroupId, allowedGroupIds);
                List<Device> allowedDevices = deviceService.list(deviceQuery);
                allowedDeviceIds = new ArrayList<>();
                for (Device device : allowedDevices) {
                    allowedDeviceIds.add(device.getId());
                }
                
                // 如果没有任何设备权限，返回空结果
                if (allowedDeviceIds.isEmpty()) {
                    Map<String, Object> result = new HashMap<>();
                    result.put("list", new ArrayList<>());
                    result.put("total", 0);
                    return Result.success(result);
                }
            }
            // 超级管理员：allowedDeviceIds = null，表示不过滤
            
            // 分页查询设备日志
            Page<DeviceLog> pageResult = deviceLogService.pageQuery(
                    page, pageSize, deviceCode, logType,
                    startTime, endTime, allowedDeviceIds);
            
            // 构造返回结果
            Map<String, Object> result = new HashMap<>();
            result.put("list", pageResult.getRecords());
            result.put("total", pageResult.getTotal());
            
            return Result.success(result);
        } catch (Exception e) {
            log.error("查询设备日志失败", e);
            return Result.error(e.getMessage());
        }
    }
}
```

**新增Service：** `DeviceLogService`

```java
package com.iot.platform.service;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.iot.platform.entity.DeviceLog;
import com.iot.platform.mapper.DeviceLogMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * 设备日志服务
 */
@Slf4j
@Service
public class DeviceLogService extends ServiceImpl<DeviceLogMapper, DeviceLog> {
    
    /**
     * 分页查询设备日志
     */
    public Page<DeviceLog> pageQuery(int page, int pageSize, String deviceCode,
                                    String logType,
                                    LocalDateTime startTime, LocalDateTime endTime,
                                    List<Long> allowedDeviceIds) {
        Page<DeviceLog> pageParam = new Page<>(page, pageSize);
        LambdaQueryWrapper<DeviceLog> query = new LambdaQueryWrapper<>();
        
        // 设备编码筛选
        if (deviceCode != null && !deviceCode.isEmpty()) {
            query.eq(DeviceLog::getDeviceCode, deviceCode);
        }
        
        // 日志类型筛选
        if (logType != null && !logType.isEmpty()) {
            query.eq(DeviceLog::getLogType, logType);
        }
        
        // 时间范围筛选
        if (startTime != null) {
            query.ge(DeviceLog::getCreateTime, startTime);
        }
        if (endTime != null) {
            query.le(DeviceLog::getCreateTime, endTime);
        }
        
        // 数据权限过滤
        if (allowedDeviceIds != null && !allowedDeviceIds.isEmpty()) {
            query.in(DeviceLog::getDeviceId, allowedDeviceIds);
        }
        
        // 按时间倒序排列
        query.orderByDesc(DeviceLog::getCreateTime);
        
        return this.page(pageParam, query);
    }
}
```

**新增Mapper：** `DeviceLogMapper`

```java
package com.iot.platform.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.iot.platform.entity.DeviceLog;
import org.apache.ibatis.annotations.Mapper;

/**
 * 设备日志Mapper
 */
@Mapper
public interface DeviceLogMapper extends BaseMapper<DeviceLog> {
}
```

**新增Entity：** `DeviceLog`

```java
package com.iot.platform.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;

import java.time.LocalDateTime;

/**
 * 设备日志实体
 */
@Data
@TableName("device_log")
public class DeviceLog {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private Long deviceId;
    
    private String deviceCode;
    
    private String logType;
    
    private String logDetail;
    
    private LocalDateTime createTime;
}
```

### 4.5 前端实现方案

#### 4.5.1 DeviceDetail.vue 修改

**新增Tab：**
```javascript
// 在现有Tab列表中添加
<button 
  class="tab" 
  :class="{ active: activeTab === 'log' }"
  @click="switchTab('log')"
>
  设备日志
</button>
```

**新增Tab内容区域：**
```vue
<!-- 设备日志Tab -->
<div class="tab-content" :class="{ active: activeTab === 'log' }">
  <!-- 日志筛选条件 -->
  <div class="filter-bar">
    <el-select v-model="logFilter.logType" placeholder="日志类型" clearable style="width: 150px;">
      <el-option label="全部" value="" />
      <el-option label="设备上线" value="online" />
      <el-option label="设备离线" value="offline" />
      <el-option label="命令下发" value="command" />
    </el-select>
    <el-date-picker
      v-model="logDateRange"
      type="datetimerange"
      range-separator="至"
      start-placeholder="开始时间"
      end-placeholder="结束时间"
      format="YYYY-MM-DD HH:mm:ss"
      value-format="YYYY-MM-DD HH:mm:ss"
      style="width: 380px;"
    />
    <el-button type="primary" @click="loadDeviceLogs">查询</el-button>
  </div>
  
  <!-- 日志列表表格 -->
  <el-table :data="deviceLogList" stripe v-loading="logLoading">
    <el-table-column prop="createTime" label="时间" width="180" />
    <el-table-column prop="logType" label="类型" width="120">
      <template #default="{ row }">
        <el-tag v-if="row.logType === 'online'" type="success">设备上线</el-tag>
        <el-tag v-else-if="row.logType === 'offline'" type="danger">设备离线</el-tag>
        <el-tag v-else type="info">命令下发</el-tag>
      </template>
    </el-table-column>
    <el-table-column prop="logDetail" label="详情" />
  </el-table>
  
  <!-- 分页器 -->
  <el-pagination
    v-model:current-page="logPagination.currentPage"
    v-model:page-size="logPagination.pageSize"
    :total="logPagination.total"
    :page-sizes="[20, 50, 100]"
    layout="total, sizes, prev, pager, next, jumper"
    @size-change="loadDeviceLogs"
    @current-change="loadDeviceLogs"
  />
</div>
```

#### 4.5.2 数据定义和API调用

```javascript
// 设备日志数据
const deviceLogList = ref([])
const logLoading = ref(false)
const logFilter = ref({
  logType: ''
})
const logDateRange = ref([])
const logPagination = reactive({
  currentPage: 1,
  pageSize: 20,
  total: 0
})

// 获取设备日志列表
const loadDeviceLogs = async () => {
  logLoading.value = true
  try {
    const res = await axios.post('/device-logs/list', {
      page: logPagination.currentPage,
      pageSize: logPagination.pageSize,
      deviceCode: deviceInfo.deviceCode,
      logType: logFilter.value.logType,
      startTime: logDateRange.value?.[0],
      endTime: logDateRange.value?.[1]
    })
    deviceLogList.value = res?.list || []
    logPagination.total = res?.total || 0
  } catch (error) {
    console.error('加载设备日志失败:', error)
    ElMessage.error('加载设备日志失败')
  } finally {
    logLoading.value = false
  }
}

// 在switchTab函数中添加设备日志的加载逻辑
const switchTab = async (tabName) => {
  activeTab.value = tabName
  
  if (tabName === 'realtime') {
    loadRealtimeData()
  } else if (tabName === 'history') {
    await loadProductAttributes()
    if (historyDateRange.value.length === 0) {
      setDefaultHistoryRange()
    }
    if (historyData.value.length === 0) {
      await queryHistory()
    }
  } else if (tabName === 'command') {
    await loadProductCommands()
  } else if (tabName === 'log') {
    // 设备日志：加载日志列表
    loadDeviceLogs()
  }
}
```

---

## 五、实施路线图

### 5.1 第一阶段（数据库和后端基础）
**目标**：创建数据库表和后端基础代码
- [ ] 创建device_log表
- [ ] 创建DeviceLog实体类
- [ ] 创建DeviceLogMapper
- [ ] 创建DeviceLogService
- [ ] 创建DeviceLogController

### 5.2 第二阶段（日志记录功能）
**目标**：实现设备日志的自动记录
- [ ] 修改DeviceService.refreshHeartbeat()记录设备上线日志
- [ ] 修改DeviceStatusCheckTask记录设备离线日志
- [ ] 修改CommandController.sendCommand()记录命令下发日志
- [ ] 测试日志记录功能

### 5.3 第三阶段（前端实现）
**目标**：实现前端设备日志Tab
- [ ] DeviceDetail.vue添加设备日志Tab
- [ ] 实现设备日志列表展示
- [ ] 实现日志筛选功能（按类型、时间）
- [ ] 实现日志分页功能
- [ ] 测试前端功能

### 5.4 第四阶段（优化增强）
**目标**：优化和增强
- [ ] 性能优化（添加索引、查询优化）
- [ ] 用户体验优化（加载状态、空状态提示）
- [ ] 日志导出功能
- [ ] 日志清理策略（定期清理历史日志）

---

## 六、总结

### 6.1 核心价值
1. **简洁明了**：统一的日志格式，类型、状态、详情
2. **易于理解**：用户易于理解和使用
3. **功能完整**：覆盖设备上线、离线、命令下发
4. **易于扩展**：易于扩展新的日志类型
5. **自动记录**：后端自动记录，数据准确可靠

### 6.2 技术亮点
1. **统一格式**：统一的日志格式
2. **简单实现**：技术实现简单
3. **性能优化**：查询性能优化（索引、分页）
4. **自动记录**：后端自动记录，无需前端干预

### 6.3 商业价值
1. **问题追溯**：完整的设备状态变化追溯能力
2. **操作记录**：完整的命令下发记录
3. **数据分析**：基于日志的数据分析
4. **效率提升**：快速发现和处理问题

---

## 七、下一步行动

### 7.1 数据库准备
- [ ] 创建device_log表
- [ ] 添加必要的索引

### 7.2 后端开发
- [ ] 创建DeviceLog实体类
- [ ] 创建DeviceLogMapper
- [ ] 创建DeviceLogService
- [ ] 创建DeviceLogController
- [ ] 修改DeviceService.refreshHeartbeat()
- [ ] 修改DeviceStatusCheckTask
- [ ] 修改CommandController.sendCommand()

### 7.3 前端开发
- [ ] DeviceDetail.vue添加设备日志Tab
- [ ] 实现设备日志列表展示
- [ ] 实现日志筛选和分页

### 7.4 测试优化
- [ ] 功能测试
- [ ] 性能测试
- [ ] 用户体验测试
